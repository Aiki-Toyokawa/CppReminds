構造体struct (ユーザー定義型)

構造体を宣言するときはstructを使う
構造体型を宣言して異なる型をまとめることができる
構造体内で宣言した変数(識別子)をメンバと呼ぶ
メンバを利用(メンバにアクセス)するにはドット演算子 . を使う


struct 構造体型名 {
   型名　識別子1;          //識別子がメンバ
   型名　識別子2;          //異なる型名で識別子を宣言できる
   ...
};

構造体変数名.メンバ = 値;  //メンバにアクセス


例)
struct Car {
	int num;
	double gas;
};

int main() {
	Car car1;              //構造体Car内の型をドット演算子を利用してなんでも使える

	std::cin >> car1.num;  //int型の値を格納できる
	std::cin >> car1.gas;  //double型の値を格納できる
        ...
}


応用)
1.構造体の初期化　カンマで区切ると順番に値が代入される
int main() {
	Car car1 = { 5806, 123.4 };
	Car car2 = { 1983, 567.8 };
}

2.構造体の代入　構造体同士で代入できる
car2 = car1;

3.引数として構造体を使う
void show(Car c);

show (car1);

void show(Car c){
        std::cout << c.num << c.gas;
}

4.構造体へのポインタを引数に使う
構造体のメンバが多いとたくさんコピーするため関数の呼び出しに時間がかかる
大きな構造体を関数の引数として扱う場合には
構造体へのポインタを引数で使う　　　　処理速度向上
参照渡しされるので関数内でメンバの値を変更することができる
ポインタからメンバにアクセスするときはアロー演算子　-> を使う
void show(Car* pC);

show (&car1)

void show(Car* pC){
        std::cout << c->num << c->gas;
}

5.構造体への参照を引数に使う
参照を引数に使うときはドット演算子ではなくアロー演算子
構造体型へのポインタからアクセスするときだけアロー演算子を使う
void show(Car c);

show (car1);

void show(Car& c){
        std::cout << c.num << c.gas;
}





















